.\" Automatically generated by Pandoc 2.9.2.1
.\"
.TH "PRINTF" "3" "October 2022" "printf 0.0.1" ""
.hy
.SH NAME
.PP
_printf - format output conversion (user-defined function)
.SH SYNOPSIS
.IP
.nf
\f[C]
#include <main.h>

int _printf(const char *format, ...);
\f[R]
.fi
.SH DESCRIPTION
.IP
.nf
\f[C]
The functions in the **_printf()** writes output to the **stdout**, the standard output stream. The **_printf()** function is basically a minimal immitation of the standard C I/O function called **printf()**.

Conversion specifiers
   A character that specifies the type of conversion to be applied.  The con\[hy]
   version specifiers and their meanings are:

   d, i   The int argument is converted to signed decimal notation.  The pre\[hy]
          cision,  if  any,  gives the minimum number of digits that must ap\[hy]
          pear; if the converted value requires fewer digits, it is padded on
          the  left  with  zeros.   The  default  precision  is 1.  When 0 is
          printed with an explicit precision 0, the output is empty.

   o, u, x, X
          The unsigned int argument is converted to unsigned octal  (o),  un\[hy]
          signed  decimal  (u),  or  unsigned hexadecimal (x and X) notation.
          The letters abcdef are used for x conversions; the  letters  ABCDEF
          are used for X conversions.  The precision, if any, gives the mini\[hy]
          mum number of digits that must appear; if the converted  value  re\[hy]
          quires  fewer digits, it is padded on the left with zeros.  The de\[hy]
          fault precision is 1.  When 0 is printed with an explicit precision
          0, the output is empty.

   e, E   The   double  argument  is  rounded  and  converted  in  the  style
          [-]d.ddde\[t+-]dd where there is one digit (which is nonzero if the  ar\[hy]
          gument  is nonzero) before the decimal-point character and the num\[hy]
          ber of digits after it is equal to the precision; if the  precision
          is missing, it is taken as 6; if the precision is zero, no decimal-
          point character appears.  An E conversion uses the letter E (rather
          than e) to introduce the exponent.  The exponent always contains at
          least two digits; if the value is zero, the exponent is 00.

   f, F   The double argument is rounded and converted to decimal notation in
          the style [-]ddd.ddd, where the number of digits after the decimal-
          point character is equal to the precision  specification.   If  the
          precision is missing, it is taken as 6; if the precision is explic\[hy]
          itly zero, no decimal-point character appears.  If a decimal  point
          appears, at least one digit appears before it.

   g, G   The double argument is converted in style f or e (or F or E  for  G
          conversions).   The  precision  specifies the number of significant
          digits.  If the precision is missing, 6 digits are  given;  if  the
          precision  is zero, it is treated as 1.  Style e is used if the ex\[hy]
          ponent from its conversion is less than -4 or greater than or equal
          to  the  precision.  Trailing zeros are removed from the fractional
          part of the result; a decimal point appears only if it is  followed
          by at least one digit.

   a, A   (C99;  not in SUSv2, but added in SUSv3) For a conversion, the dou\[hy]
          ble argument is converted to hexadecimal notation (using  the  let\[hy]
          ters abcdef) in the style [-]0xh.hhhhp\[t+-]d; for A conversion the pre\[hy]
          fix 0X, the letters ABCDEF, and the exponent separator P  is  used.
          There  is  one  hexadecimal digit before the decimal point, and the
          number of digits after it is equal to the precision.   The  default
          precision  suffices  for an exact representation of the value if an
          exact representation in base 2 exists and otherwise is sufficiently
          large  to  distinguish values of type double.  The digit before the
          decimal point is unspecified for nonnormalized numbers, and nonzero
          but otherwise unspecified for normalized numbers.  The exponent al\[hy]
          ways contains at least one digit; if the value is zero,  the  expo\[hy]
          nent is 0.

   c      If  no  l  modifier is present, the int argument is converted to an
          unsigned char, and the resulting character is  written.   If  an  l
          modifier  is  present, the wint_t (wide character) argument is con\[hy]
          verted to a multibyte sequence by a call to  the  wcrtomb(3)  func\[hy]
          tion,  with  a  conversion state starting in the initial state, and
          the resulting multibyte string is written.

   s      If no l modifier is present: the const char * argument is  expected
          to  be  a  pointer  to  an  array  of  character type (pointer to a
          string).  Characters from the array are written up to (but not  in\[hy]
          cluding)  a  terminating null byte (\[aq]\[rs]0\[aq]); if a precision is speci\[hy]
          fied, no more than the number specified are written.  If  a  preci\[hy]
          sion  is  given,  no null byte need be present; if the precision is
          not specified, or is greater than the size of the array, the  array
          must contain a terminating null byte.

      If  an  l  modifier is present: the const wchar_t * argument is ex\[hy]
          pected to be a pointer to an array of wide characters.  Wide  char\[hy]
          acters  from  the array are converted to multibyte characters (each
          by a call to the  wcrtomb(3)  function,  with  a  conversion  state
          starting  in the initial state before the first wide character), up
          to and including a terminating null wide character.  The  resulting
          multibyte characters are written up to (but not including) the ter\[hy]
          minating null byte.  If a precision is  specified,  no  more  bytes
          than  the  number  specified  are written, but no partial multibyte
          characters are written.  Note that  the  precision  determines  the
          number  of  bytes  written,  not  the  number of wide characters or
          screen positions.  The array must contain a terminating  null  wide
          character,  unless a precision is given and it is so small that the
          number of bytes written exceeds it before the end of the  array  is
          reached.

   C      (Not  in  C99 or C11, but in SUSv2, SUSv3, and SUSv4.)  Synonym for
          lc.  Don\[aq]t use.

   S      (Not in C99 or C11, but in SUSv2, SUSv3, and SUSv4.)   Synonym  for
          ls.  Don\[aq]t use.

   p      The void * pointer argument is printed in hexadecimal (as if by %#x
          or %#lx).

   n      The number of characters written so far is stored into the  integer
          pointed  to  by the corresponding argument.  That argument shall be
          an int *, or variant whose size matches the  (optionally)  supplied
          integer  length  modifier.  No argument is converted.  (This speci\[hy]
          fier is not supported by the bionic C library.)   The  behavior  is
          undefined  if  the  conversion  specification includes any flags, a
          field width, or a precision.

   m      (Glibc extension; supported by uClibc and musl.)  Print  output  of
          strerror(errno).  No argument is required.

   %      A  \[aq]%\[aq] is written.  No argument is converted.  The complete conver\[hy]
          sion specification is \[aq]%%\[aq].
\f[R]
.fi
.SH RETURN VALUE
.IP
.nf
\f[C]
   Upon successful return, these functions return the  number  of  characters
   printed (excluding the null byte used to end output to strings).
\f[R]
.fi
.SH AUTHORS
Carter Malatji, Ruvimbo Delia Mawoyo.
